# Client

**memtable-cli** 是一个可交互式的客户端，支持命令补全、命令提示、历史命令以及搜索功能，它实现了 GNU Readline 的部分功能。

## 相关技术

**memtable-cli** 的实现所用到的相关技术有`Termios`和终端控制符。

### Termios

在标准设置下，用户的标准输入会被回显在标准输出上，并且不能够实时地被程序检测到。为了实现支持命令补全功能的交互式客户端，需要通过`Termios`对终端进行设置，实时读取用户输入。`Termios`是 Linux 中描述串口配置的一个数据结构，通过系统调用`sys_ioctl`可以对其进行设置，具体内容读者可以根据关键字进行检索。

### IO 控制层

在标准设置下，用户的标准输入并不会直接通过管道送入进程的标准输入，而是先缓存在进程的 IO 控制层中。这是为了避免进程自行实现用户的回退操作，以及控制信号等操作。

### 终端控制符

终端控制符是特殊的标准输出序列，通常以`'\033'`即`'ESC'`开头。通过输出相应的终端控制符，能够调控终端的一些行为，如移动终端的光标，清除终端上的某个字符。用户的一些控制信号同样也是通过终端控制符输入的，在标准设置下，IO 控制层会识别控制信号并使用`kill`命令给进程发送转换后的signal。

## 字符处理函数

为了能够实时读取用户的输入，必须要关闭终端的标准设置，`MemTable/utils/readline/util.go`路径下有相关代码的实现。关闭终端的标准设置后，有以下几个问题需要处理：

- 需要实现用户输入的缓存，记录用户的输入以及修改；
- 需要实现用户输入的回显功能，即用户输入需要显示在标准输出中；
- 需要识别并处理用户的控制信号，如`[CTRL]+[C]`。

以上几个功能，实现在`Terminal.handleInput`以及`key_handler.go`的相关函数中。这些函数的主要工作是缓存并识别用户的输入，通过终端控制符在标准输出上打印出用户当前的输入，即回显功能。比较特殊的是`'\033'`字符，该字符代表用户可能按下了 ESC 键，或使用了组合控制键，当识别到`'\033'`字符时需要判断是否为终端控制符。

## 命令补全与提示

命令补全与提示是基于前缀树实现的，程序在初始化时将需要补全的命令注册到前缀树中，当用户按下`'[TAB]'`键时，使用当前缓存的用户输入来查询前缀树中是否有匹配命令。如果有匹配命令，则将这些命令打印到标准输出上。命令的打印和阴影效果也是使用终端控制符来实现的。
<div align='center'><img src="../images/completion.png" alt=""></div>

这里的具体操作流程是：换行-检查并清空当前行-输出匹配命令-根据选择的命令输出背景。

## 屏幕闪烁

当命令补全或历史命令搜索完毕时，需要闪烁屏幕来提醒用户。通过保存终端内容-清屏-恢复，就可以实现终端屏幕的闪烁。

```go
// TwinkleScreen 闪烁一次屏幕
func TwinkleScreen() {
	x, y := ReadCursor()
	// 保存屏幕内容，然后清屏
	FlushString(fmt.Sprintf("\033[?47h\033[2J\033[%d;%dH", y, x))
	time.Sleep(5 * time.Millisecond)
	// 等待一段时间后恢复屏幕内容
	FlushString("\033[?47l")
}
```
